/**
 * User Join Actions
 * 
 * Handles user join events from Whop webhooks and initiates the chat funnel system.
 * This is part of Phase 1 of the Two-Phase Chat Initiation System.
 */

import { and, eq, sql } from "drizzle-orm";
import { db } from "../supabase/db-server";
import { experiences, funnels, conversations, messages, users, funnelAnalytics } from "../supabase/schema";
import { whopSdk } from "../whop-sdk";
import { createConversation, addMessage } from "./simplified-conversation-actions";
import { deleteExistingConversationsByWhopUserId, deleteExistingConversationsByMembershipId } from "./user-management-actions";
import type { FunnelFlow } from "../types/funnel";
import { updateFunnelGrowthPercentages } from "./funnel-actions";
import { safeBackgroundTracking, trackAwarenessBackground } from "../analytics/background-tracking";

/**
 * Generate app link for the current experience
 * Based on Whop documentation: https://whop.com/joined/tooler/tooler-kWyK3oMAwIYyMf/app/
 * 
 * @param experienceId - The experience ID
 * @returns App link URL
 */
async function generateAppLink(experienceId: string): Promise<string> {
	try {
		// Get the experience to find the stored link or generate one
		const experience = await db.query.experiences.findFirst({
			where: eq(experiences.whopExperienceId, experienceId),
			columns: { 
				whopCompanyId: true, 
				whopExperienceId: true,
				link: true
			}
		});

		if (!experience) {
			console.error(`[App Link] No experience found for ${experienceId}`);
			return "https://whop.com/apps/";
		}

		// Use stored link if available (generated by product-sync)
		if (experience.link) {
			console.log(`[App Link] Using stored app link for experience ${experienceId}: ${experience.link}`);
			return experience.link;
		}

		// Fallback: Generate app link using the pattern: https://whop.com/joined/{companyId}/app/
		if (experience.whopCompanyId) {
			const appLink = `https://whop.com/joined/${experience.whopCompanyId}/app/`;
			console.log(`[App Link] Generated fallback app link for experience ${experienceId}: ${appLink}`);
			return appLink;
		}

		console.error(`[App Link] No whopCompanyId found for experience ${experienceId}`);
		return "https://whop.com/apps/";
	} catch (error) {
		console.error(`[App Link] Error generating app link for experience ${experienceId}:`, error);
		return "https://whop.com/apps/";
	}
}

/**
 * Look up admin user by experience ID
 * Returns the admin's first name if found, null otherwise
 */
async function lookupAdminUser(experienceId: string): Promise<string | null> {
	try {
		console.log(`[Admin Lookup] Looking up admin user for experience: ${experienceId}`);
		
		const adminUser = await db.query.users.findFirst({
			where: and(
				eq(users.experienceId, experienceId),
				eq(users.accessLevel, "admin")
			),
		});

		if (adminUser?.name) {
			// Return first word of admin name (same logic as [USER] placeholder)
			const firstName = adminUser.name.split(' ')[0];
			console.log(`[Admin Lookup] Found admin user: ${adminUser.name} -> firstName: ${firstName}`);
			return firstName;
		} else {
			console.log(`[Admin Lookup] No admin user found for experience: ${experienceId}`);
			return null;
		}
	} catch (error) {
		console.error(`[Admin Lookup] Error looking up admin user for experience ${experienceId}:`, error);
		return null;
	}
}

/**
 * Look up current user by conversation ID
 * Returns the user's first name if found, null otherwise
 */
async function lookupCurrentUser(conversationId: string): Promise<string | null> {
	try {
		console.log(`[User Lookup] Looking up current user for conversation: ${conversationId}`);
		
		// Get conversation to find whopUserId
		const conversation = await db.query.conversations.findFirst({
			where: eq(conversations.id, conversationId),
		});

		if (!conversation?.whopUserId) {
			console.log(`[User Lookup] No conversation or whopUserId found for conversation: ${conversationId}`);
			return null;
		}

		// Get user by whopUserId
		const user = await db.query.users.findFirst({
			where: eq(users.whopUserId, conversation.whopUserId),
		});

		if (user?.name) {
			// Return first word of user name (same logic as admin lookup)
			const firstName = user.name.split(' ')[0];
			console.log(`[User Lookup] Found user: ${user.name} -> firstName: ${firstName}`);
			return firstName;
		} else {
			console.log(`[User Lookup] No user found for whopUserId: ${conversation.whopUserId}`);
			return null;
		}
	} catch (error) {
		console.error(`[User Lookup] Error looking up current user for conversation ${conversationId}:`, error);
		return null;
	}
}

/**
 * Look up company name by experience ID
 * Returns the experience name (company name) if found, null otherwise
 */
async function lookupCompanyName(experienceId: string): Promise<string | null> {
	try {
		console.log(`[Company Lookup] Looking up experience name for experience: ${experienceId}`);
		
		const experience = await db.query.experiences.findFirst({
			where: eq(experiences.id, experienceId),
			columns: { name: true }
		});

		if (experience?.name) {
			console.log(`[Company Lookup] Found experience name: ${experience.name}`);
			return experience.name;
		} else {
			console.log(`[Company Lookup] No experience name found for experience: ${experienceId}`);
			return null;
		}
	} catch (error) {
		console.error(`[Company Lookup] Error looking up experience name for experience ${experienceId}:`, error);
		return null;
	}
}

/**
 * Resolve placeholders in message content
 * Handles [USER], [WHOP_OWNER], and [WHOP] placeholders
 */
async function resolvePlaceholders(message: string, experienceId: string, conversationId: string): Promise<string> {
	let resolvedMessage = message;

	// Resolve [WHOP_OWNER] placeholder
	if (resolvedMessage.includes('[WHOP_OWNER]')) {
		const adminName = await lookupAdminUser(experienceId);
		if (adminName) {
			resolvedMessage = resolvedMessage.replace(/\[WHOP_OWNER\]/g, adminName);
			console.log(`[Placeholder Resolution] Replaced [WHOP_OWNER] with: ${adminName}`);
		} else {
			console.log(`[Placeholder Resolution] Admin user not found, keeping [WHOP_OWNER] placeholder`);
		}
	}

	// Resolve [USER] placeholder
	if (resolvedMessage.includes('[USER]')) {
		const userName = await lookupCurrentUser(conversationId);
		if (userName) {
			resolvedMessage = resolvedMessage.replace(/\[USER\]/g, userName);
			console.log(`[Placeholder Resolution] Replaced [USER] with: ${userName}`);
		} else {
			console.log(`[Placeholder Resolution] Current user not found, keeping [USER] placeholder`);
		}
	}

	// Resolve [WHOP] placeholder
	if (resolvedMessage.includes('[WHOP]')) {
		const companyName = await lookupCompanyName(experienceId);
		if (companyName) {
			resolvedMessage = resolvedMessage.replace(/\[WHOP\]/g, companyName);
			console.log(`[Placeholder Resolution] Replaced [WHOP] with: ${companyName}`);
		} else {
			console.log(`[Placeholder Resolution] Company name not found, keeping [WHOP] placeholder`);
		}
	}

	return resolvedMessage;
}

/**
 * Handle user join event from webhook
 * 
 * @param userId - Whop user ID
 * @param productId - Whop product ID (from membership webhook)
 * @param webhookData - Full webhook data
 * @param membershipId - Whop membership ID (for DM operations)
 */
export async function handleUserJoinEvent(
	userId: string,
	productId: string,
	webhookData?: any,
	membershipId?: string,
): Promise<void> {
	try {
		console.log(`[USER-JOIN DEBUG] Processing user join event: ${userId} for product ${productId}`);
		console.log(`[USER-JOIN DEBUG] Webhook data:`, JSON.stringify(webhookData, null, 2));

		// Validate required fields
		if (!userId || !productId) {
			console.error("Missing required fields: userId or productId");
			return;
		}

		// Step 1: Find the experience by page_id (company ID)
		// This is the most reliable way since page_id is the company that owns the app
		console.log(`[USER-JOIN DEBUG] Looking for experience with whopCompanyId: ${webhookData.data.page_id}`);
		
		const experience = await db.query.experiences.findFirst({
			where: eq(experiences.whopCompanyId, webhookData.data.page_id),
		});

		if (!experience) {
			console.error(`[USER-JOIN DEBUG] No experience found for page_id ${webhookData.data.page_id}`);
			const availableExperiences = await db.query.experiences.findMany({
				columns: { whopCompanyId: true, whopExperienceId: true, name: true }
			});
			console.error(`[USER-JOIN DEBUG] Available experiences:`, availableExperiences);
			return;
		}

		console.log(`Found experience ${experience.whopExperienceId} for product ${productId}`);

		// Step 2: Create user record (if not exists)
		const existingUser = await db.query.users.findFirst({
			where: and(
				eq(users.whopUserId, userId),
				eq(users.experienceId, experience.id)
			),
		});

		if (!existingUser) {
			// Fetch user data from WHOP API (same strategy as user-context)
			const whopUser = await whopSdk.users.getUser({ userId: userId });

			if (!whopUser) {
				console.error("User not found in WHOP API:", userId);
				return;
			}

			// Determine initial access level from Whop API (same strategy as user-context)
			let accessLevel = "customer"; // Default fallback
			
			try {
				const accessResult = await whopSdk.access.checkIfUserHasAccessToExperience({
					userId: userId,
					experienceId: experience.whopExperienceId,
				});
				accessLevel = accessResult.accessLevel || "no_access";
				console.log(`Whop API access level: ${accessLevel}`);
			} catch (error) {
				console.error("Error checking initial access level:", error);
				accessLevel = "no_access"; // More restrictive fallback
			}
			
			// Create user in our database (same strategy as user-context)
			const [newUser] = await db
				.insert(users)
				.values({
					whopUserId: whopUser.id,
					experienceId: experience.id, // Link to experience
					email: "", // Email is not available in public profile
					name: whopUser.name || whopUser.username || "Unknown User",
					avatar: whopUser.profilePicture?.sourceUrl || null,
					credits: 0, // Customers get 0 credits
					accessLevel: accessLevel,
				})
				.returning();

			// Fetch the user with experience relation (same strategy as user-context)
			const user = await db.query.users.findFirst({
				where: eq(users.id, newUser.id),
				with: {
					experience: true,
				},
			});

			console.log(`✅ Created user record for ${userId} with access: ${accessLevel}`);
		} else {
			console.log(`User ${userId} already exists in experience ${experience.id}`);
		}

		// Step 3: Find deployed funnel for this experience (no product filtering)
		const liveFunnel = await db.query.funnels.findFirst({
			where: and(
				eq(funnels.experienceId, experience.id),
				eq(funnels.isDeployed, true)
			),
			columns: {
				id: true,
				flow: true,
				experienceId: true,
			},
		});

		if (!liveFunnel || !liveFunnel.flow) {
			console.log(`✅ Correctly handled: No deployed funnel found for experience ${experience.id} - user joined but no DM needed`);
			return;
		}

		console.log(`Found live funnel ${liveFunnel.id} for experience ${experience.id} and product ${productId}`);

		// Step 4: Get user name and company name for personalization
		const user = await db.query.users.findFirst({
			where: and(
				eq(users.whopUserId, userId),
				eq(users.experienceId, experience.id)
			),
		});

		// Step 5: Get admin name for [WHOP_OWNER] placeholder
		const adminUser = await db.query.users.findFirst({
			where: and(
				eq(users.experienceId, experience.id),
				eq(users.accessLevel, "admin")
			),
		});
		const adminName = adminUser?.name ? adminUser.name.split(' ')[0] : experience.name;

		// Step 6: Extract transition message from funnel flow with personalization
		// We'll get the user name after conversation is created using lookupCurrentUser()
		let transitionMessage = await getTransitionMessage(
			liveFunnel.flow, 
			undefined, // Will be resolved after conversation creation
			adminName,
			experience.whopExperienceId
		);
		if (!transitionMessage) {
			console.error(`No transition message found in funnel ${liveFunnel.id}`);
			return;
		}

		// Step 6: Delete any existing conversations for this user
		// Delete by both whopUserId and membershipId to be safe
		const deletedByUserId = await deleteExistingConversationsByWhopUserId(userId, experience.id);
		console.log(`[USER-JOIN] Deleted ${deletedByUserId} conversations by whopUserId ${userId}`);
		
		let deletedByMembershipId = 0;
		if (membershipId) {
			deletedByMembershipId = await deleteExistingConversationsByMembershipId(membershipId, experience.id);
			console.log(`[USER-JOIN] Deleted ${deletedByMembershipId} conversations by membershipId ${membershipId}`);
		}

		// Step 6: Check if conversation already exists (race condition protection)
		const existingConversation = await db.query.conversations.findFirst({
			where: and(
				eq(conversations.whopUserId, userId),
				eq(conversations.experienceId, experience.id),
				eq(conversations.status, "active")
			),
		});

		if (existingConversation) {
			console.log(`[USER-JOIN] Conversation still exists for user ${userId} in experience ${experience.id} after deleting ${deletedByUserId + deletedByMembershipId} conversations - this indicates a race condition or deletion failed`);
			return;
		}

		// Step 8: Create conversation record with TRANSITION stage
		console.log(`[USER-JOIN] Creating new conversation for user ${userId} in experience ${experience.id}`);
		const conversationId = await createConversation(
			experience.id,
			liveFunnel.id,
			userId, // Use actual whopUserId
			liveFunnel.flow.startBlockId, // This should be TRANSITION block
			membershipId, // Pass membershipId separately
			productId, // Pass whop_product_id
		);
		console.log(`[USER-JOIN] Created conversation ${conversationId} for user ${userId}`);

		// Step 8.5: Resolve [USER] placeholder using resolvePlaceholders() after conversation is created
		const resolvedTransitionMessage = await resolvePlaceholders(
			transitionMessage,
			experience.id,
			conversationId
		);

	// Send transition DM and record it
	const dmUserId = membershipId || userId; // Use membershipId for DM operations
	const dmSent = await sendTransitionDM(dmUserId, resolvedTransitionMessage, conversationId);
	if (!dmSent) {
		console.error(`Failed to send DM to user ${userId}`);
		return;
	}

	// Step 9: Update conversation to WELCOME stage and save WELCOME message
	console.log(`[USER-JOIN] Updating conversation ${conversationId} to WELCOME stage`);
	await updateConversationToWelcomeStage(conversationId, liveFunnel.flow);

	// Track awareness (starts) when welcome message is sent - BACKGROUND PROCESSING
	console.log(`🚀 [USER-JOIN] About to track awareness for experience ${experience.id}, funnel ${liveFunnel.id}`);
	safeBackgroundTracking(() => trackAwarenessBackground(experience.id, liveFunnel.id));


	// DM monitoring is now handled by cron jobs - no need to start monitoring service
	// The cron jobs will automatically detect and process this conversation
	console.log(`Conversation ${conversationId} created - cron jobs will handle DM monitoring`);

		console.log(`Successfully processed user join for ${userId} with funnel ${liveFunnel.id} for product ${productId}`);
	} catch (error) {
		console.error("Error handling user join event:", error);
		// Don't throw - we want webhook to return 200 even if processing fails
	}
}


/**
 * Extract transition message from funnel flow with personalization
 * 
 * @param funnelFlow - The funnel flow object
 * @param userName - User's name for [USER] replacement
 * @param companyName - Company name for [WHOP] replacement
 * @param experienceId - Experience ID for [LINK] replacement
 * @returns Transition message or null
 */
export async function getTransitionMessage(
	funnelFlow: FunnelFlow, 
	userName?: string, 
	companyName?: string,
	experienceId?: string
): Promise<string | null> {
	try {
		if (!funnelFlow.startBlockId) {
			console.error("No startBlockId found in funnel flow");
			return null;
		}

		const startBlock = funnelFlow.blocks[funnelFlow.startBlockId];
		if (!startBlock) {
			console.error(`Start block ${funnelFlow.startBlockId} not found in funnel flow`);
			return null;
		}

		if (!startBlock.message || startBlock.message.trim() === "") {
			console.error("Start block has no message or empty message");
			return null;
		}

		let transitionMessage = startBlock.message;

		// Replace [USER] with first word of user name
		if (userName) {
			const firstName = userName.split(' ')[0]; // Get only the first word
			transitionMessage = transitionMessage.replace(/\[USER\]/g, firstName);
		}

		// Replace [WHOP] with actual company name
		if (companyName) {
			transitionMessage = transitionMessage.replace(/\[WHOP\]/g, companyName);
		}

		// Replace [WHOP_OWNER] with actual company name (new format)
		if (companyName) {
			transitionMessage = transitionMessage.replace(/\[WHOP_OWNER\]/g, companyName);
		}

		// Resolve [LINK] placeholder with app link
		if (transitionMessage.includes('[LINK]')) {
			if (experienceId) {
				const appLink = await generateAppLink(experienceId);
				transitionMessage = transitionMessage.replace(/\[LINK\]/g, appLink);
				console.log(`[Transition Message] Replaced [LINK] with: ${appLink}`);
			} else {
				console.log(`[Transition Message] No experienceId provided, keeping [LINK] placeholder`);
			}
		}

		// Add UserChat link if not already present and no [LINK] placeholder
		if (!transitionMessage.includes('[LINK]') && !transitionMessage.includes('UserChat') && !transitionMessage.includes('whop.com')) {
			if (experienceId) {
				const appLink = await generateAppLink(experienceId);
				transitionMessage += `\n\n${appLink}`;
			} else {
				transitionMessage += "\n\n[LINK]";
			}
		}

		return transitionMessage;
	} catch (error) {
		console.error("Error extracting welcome message:", error);
		return null;
	}
}

/**
 * Send transition DM to user
 * 
 * @param whopUserId - Whop user ID
 * @param message - Message to send
 * @returns Success boolean
 */
export async function sendTransitionDM(
	whopUserId: string,
	message: string,
	conversationId?: string,
): Promise<boolean> {
	try {
		console.log(`Sending DM to user ${whopUserId}: ${message}`);

		const result = await whopSdk.messages.sendDirectMessageToUser({
			toUserIdOrUsername: whopUserId,
			message: message,
		});

		// Record transition message in database if conversationId is provided
		if (conversationId) {
			await addMessage(conversationId, "bot", message);
			console.log(`Recorded transition message in conversation ${conversationId}`);
		}

		console.log(`DM sent successfully to user ${whopUserId}`);
		return true;
	} catch (error) {
		console.error(`Error sending DM to user ${whopUserId}:`, error);
		
		// Handle specific error cases
		if (error instanceof Error) {
			if (error.message.includes("rate limit")) {
				console.error("Rate limited when sending DM");
			} else if (error.message.includes("invalid user")) {
				console.error("Invalid user ID provided");
			}
		}
		
		return false;
	}
}

/**
 * Update conversation to WELCOME stage and save WELCOME message
 * 
 * @param conversationId - ID of the conversation to update
 * @param funnelFlow - Funnel flow to get WELCOME block
 */
export async function updateConversationToWelcomeStage(
	conversationId: string,
	funnelFlow: FunnelFlow,
): Promise<void> {
	try {
		// Get conversation to find experienceId
		const conversation = await db.query.conversations.findFirst({
			where: eq(conversations.id, conversationId),
		});

		if (!conversation) {
			console.error(`No conversation found for ${conversationId}`);
			return;
		}

		// Find the WELCOME stage
		const welcomeStage = funnelFlow.stages.find(
			stage => stage.name === "WELCOME"
		);
		
		if (!welcomeStage || welcomeStage.blockIds.length === 0) {
			console.error(`No WELCOME stage found in funnel flow for conversation ${conversationId}`);
			return;
		}
		
		const firstWelcomeBlockId = welcomeStage.blockIds[0];
		const welcomeBlock = funnelFlow.blocks[firstWelcomeBlockId];
		
		if (!welcomeBlock) {
			console.error(`WELCOME block ${firstWelcomeBlockId} not found in funnel flow for conversation ${conversationId}`);
			return;
		}
		
		// Update conversation to WELCOME stage (using same pattern as navigate-funnel)
		const updatedConversation = await db
			.update(conversations)
			.set({
				currentBlockId: firstWelcomeBlockId,
				userPath: [firstWelcomeBlockId], // Start fresh with WELCOME block
				updatedAt: new Date(),
			})
			.where(eq(conversations.id, conversationId))
			.returning();
		
		console.log(`[USER-JOIN] Updated conversation ${conversationId} to WELCOME stage with block ${firstWelcomeBlockId}`, updatedConversation);
		
		// Save WELCOME message to database with placeholder resolution
		if (welcomeBlock.message) {
			// Resolve placeholders before saving
			const resolvedMessage = await resolvePlaceholders(
				welcomeBlock.message, 
				conversation.experienceId, 
				conversationId
			);
			
			await db.insert(messages).values({
				conversationId: conversationId,
				type: "bot",
				content: resolvedMessage,
				metadata: {
					blockId: firstWelcomeBlockId,
				},
			});
			console.log(`[USER-JOIN] Saved WELCOME message to database for conversation ${conversationId}:`, resolvedMessage.substring(0, 100) + '...');
		}
		
	} catch (error) {
		console.error(`[USER-JOIN] Error updating conversation ${conversationId} to WELCOME stage:`, error);
		throw error;
	}
}

// Old tracking functions removed - now using background tracking service

