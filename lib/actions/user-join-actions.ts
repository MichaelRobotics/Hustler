/**
 * User Join Actions
 * 
 * Handles user join events from Whop webhooks and initiates the chat funnel system.
 * This is part of Phase 1 of the Two-Phase Chat Initiation System.
 */

import { and, eq, sql } from "drizzle-orm";
import { db } from "../supabase/db-server";
import { experiences, funnels, conversations, messages, users, funnelAnalytics } from "../supabase/schema";
import { whopSdk } from "../whop-sdk";
import { createConversation, addMessage } from "./simplified-conversation-actions";
import { deleteExistingConversationsByWhopUserId, deleteExistingConversationsByMembershipId } from "./user-management-actions";
import type { FunnelFlow } from "../types/funnel";
import { updateFunnelGrowthPercentages } from "./funnel-actions";
import { safeBackgroundTracking, trackAwarenessBackground } from "../analytics/background-tracking";

/**
 * Generate app link for the current experience
 * Based on Whop documentation: https://whop.com/joined/tooler/tooler-kWyK3oMAwIYyMf/app/
 * 
 * @param experienceId - The experience ID
 * @returns App link URL
 */
async function generateAppLink(experienceId: string): Promise<string> {
	try {
		// Get the experience to find the stored link or generate one
		const experience = await db.query.experiences.findFirst({
			where: eq(experiences.id, experienceId),
			columns: { 
				whopCompanyId: true, 
				whopExperienceId: true,
				link: true
			}
		});

		if (!experience) {
			console.error(`[App Link] No experience found for ${experienceId}`);
			return "https://whop.com/apps/";
		}

		// Use stored link if available (generated by product-sync)
		if (experience.link) {
			console.log(`[App Link] Using stored app link for experience ${experienceId}: ${experience.link}`);
			return experience.link;
		}

		// Fallback: Generate app link using the pattern: https://whop.com/joined/{companyId}/app/
		if (experience.whopCompanyId) {
			const appLink = `https://whop.com/joined/${experience.whopCompanyId}/app/`;
			console.log(`[App Link] Generated fallback app link for experience ${experienceId}: ${appLink}`);
			return appLink;
		}

		console.error(`[App Link] No whopCompanyId found for experience ${experienceId}`);
		return "https://whop.com/apps/";
	} catch (error) {
		console.error(`[App Link] Error generating app link for experience ${experienceId}:`, error);
		return "https://whop.com/apps/";
	}
}

/**
 * Handle user join event from webhook
 * 
 * @param userId - Whop user ID
 * @param productId - Whop product ID (from membership webhook)
 * @param webhookData - Full webhook data
 * @param membershipId - Whop membership ID (for DM operations)
 */
export async function handleUserJoinEvent(
	userId: string,
	productId: string,
	webhookData?: any,
	membershipId?: string,
): Promise<void> {
	try {
		console.log(`Processing user join event: ${userId} for product ${productId}`);

		// Validate required fields
		if (!userId || !productId) {
			console.error("Missing required fields: userId or productId");
			return;
		}

		// Step 1: Find the experience by page_id (company ID)
		// This is the most reliable way since page_id is the company that owns the app
		const experience = await db.query.experiences.findFirst({
			where: eq(experiences.whopCompanyId, webhookData.data.page_id),
		});

		if (!experience) {
			console.error(`No experience found for page_id ${webhookData.data.page_id}`);
			console.error(`Available experiences:`, await db.query.experiences.findMany({
				columns: { whopCompanyId: true, whopExperienceId: true, name: true }
			}));
			return;
		}

		console.log(`Found experience ${experience.whopExperienceId} for product ${productId}`);

		// Step 2: Create user record (if not exists)
		const existingUser = await db.query.users.findFirst({
			where: and(
				eq(users.whopUserId, userId),
				eq(users.experienceId, experience.id)
			),
		});

		if (!existingUser) {
			// Create user record with required fields
			await db.insert(users).values({
				whopUserId: userId,
				experienceId: experience.id,
				email: `user_${userId}@whop.local`, // Default email since we don't have it from webhook
				name: `User ${userId}`, // Default name since we don't have it from webhook
				accessLevel: "customer",
				createdAt: new Date(),
				updatedAt: new Date(),
			});
			console.log(`Created user record for ${userId} in experience ${experience.id}`);
		} else {
			console.log(`User ${userId} already exists in experience ${experience.id}`);
		}

		// Step 3: Find deployed funnel for this experience AND product
		const liveFunnel = await db.query.funnels.findFirst({
			where: and(
				eq(funnels.experienceId, experience.id),
				eq(funnels.whopProductId, productId),
				eq(funnels.isDeployed, true)
			),
			columns: {
				id: true,
				flow: true,
				experienceId: true,
				whopProductId: true,
			},
		});

		if (!liveFunnel || !liveFunnel.flow) {
			console.log(`No deployed funnel found for experience ${experience.id} and product ${productId} - ignoring webhook`);
			return;
		}

		console.log(`Found live funnel ${liveFunnel.id} for experience ${experience.id} and product ${productId}`);

		// Step 4: Get user name and company name for personalization
		const user = await db.query.users.findFirst({
			where: and(
				eq(users.whopUserId, userId),
				eq(users.experienceId, experience.id)
			),
		});

		// Step 5: Extract transition message from funnel flow with personalization
		const transitionMessage = await getTransitionMessage(
			liveFunnel.flow, 
			user?.name || `User ${userId}`, 
			experience.name,
			experience.id
		);
		if (!transitionMessage) {
			console.error(`No transition message found in funnel ${liveFunnel.id}`);
			return;
		}

		// Step 6: Delete any existing conversations for this user
		// Delete by both whopUserId and membershipId to be safe
		const deletedByUserId = await deleteExistingConversationsByWhopUserId(userId, experience.id);
		console.log(`[USER-JOIN] Deleted ${deletedByUserId} conversations by whopUserId ${userId}`);
		
		let deletedByMembershipId = 0;
		if (membershipId) {
			deletedByMembershipId = await deleteExistingConversationsByMembershipId(membershipId, experience.id);
			console.log(`[USER-JOIN] Deleted ${deletedByMembershipId} conversations by membershipId ${membershipId}`);
		}

		// Step 6: Check if conversation already exists (race condition protection)
		const existingConversation = await db.query.conversations.findFirst({
			where: and(
				eq(conversations.whopUserId, userId),
				eq(conversations.experienceId, experience.id),
				eq(conversations.status, "active")
			),
		});

		if (existingConversation) {
			console.log(`[USER-JOIN] Conversation still exists for user ${userId} in experience ${experience.id} after deleting ${deletedByUserId + deletedByMembershipId} conversations - this indicates a race condition or deletion failed`);
			return;
		}

		// Step 8: Create conversation record with TRANSITION stage
		console.log(`[USER-JOIN] Creating new conversation for user ${userId} in experience ${experience.id}`);
		const conversationId = await createConversation(
			experience.id,
			liveFunnel.id,
			userId, // Use actual whopUserId
			liveFunnel.flow.startBlockId, // This should be TRANSITION block
			membershipId, // Pass membershipId separately
		);
		console.log(`[USER-JOIN] Created conversation ${conversationId} for user ${userId}`);

	// Send transition DM and record it
	const dmUserId = membershipId || userId; // Use membershipId for DM operations
	const dmSent = await sendTransitionDM(dmUserId, transitionMessage, conversationId);
	if (!dmSent) {
		console.error(`Failed to send DM to user ${userId}`);
		return;
	}

	// Step 9: Update conversation to WELCOME stage and save WELCOME message
	console.log(`[USER-JOIN] Updating conversation ${conversationId} to WELCOME stage`);
	await updateConversationToWelcomeStage(conversationId, liveFunnel.flow);

	// Track awareness (starts) when welcome message is sent - BACKGROUND PROCESSING
	console.log(`ðŸš€ [USER-JOIN] About to track awareness for experience ${experience.id}, funnel ${liveFunnel.id}`);
	safeBackgroundTracking(() => trackAwarenessBackground(experience.id, liveFunnel.id));

	// Get the member ID from the DM conversation
	let memberId = null;
	try {
		// Wait a moment for the DM conversation to be created
		await new Promise(resolve => setTimeout(resolve, 2000));
		
		// Get the DM conversations to find the new one
		const dmConversations = await whopSdk.messages.listDirectMessageConversations();
		const newConversation = dmConversations.find(conv => 
			// Look for a conversation that contains our welcome message
			conv.lastMessage?.content?.includes('Welcome, [Username]!') ||
			conv.lastMessage?.content?.includes('Welcome!') ||
			conv.lastMessage?.content?.includes('Welcome to')
		);
		
		if (newConversation) {
			// Find the member ID for our user
			// Look for a member that matches our userId or membershipId
			const userMember = newConversation.feedMembers.find(member => 
				member.id === userId || 
				member.id === membershipId ||
				member.username === userId ||
				member.username === membershipId
			);
			if (userMember) {
				memberId = userMember.id;
				console.log(`Found member ID for user ${userId}: ${memberId}`);
				
				// Update conversation with member ID
				await db.update(conversations)
					.set({
						metadata: {
							...liveFunnel.flow,
							whopMemberId: memberId,
						},
					})
					.where(eq(conversations.id, conversationId));
			}
		}
	} catch (error) {
		console.error('Error getting member ID for customer:', error);
	}

	// DM monitoring is now handled by cron jobs - no need to start monitoring service
	// The cron jobs will automatically detect and process this conversation
	console.log(`Conversation ${conversationId} created - cron jobs will handle DM monitoring`);

		console.log(`Successfully processed user join for ${userId} with funnel ${liveFunnel.id} for product ${productId}`);
	} catch (error) {
		console.error("Error handling user join event:", error);
		// Don't throw - we want webhook to return 200 even if processing fails
	}
}


/**
 * Extract transition message from funnel flow with personalization
 * 
 * @param funnelFlow - The funnel flow object
 * @param userName - User's name for [USER] replacement
 * @param companyName - Company name for [WHOP] replacement
 * @param experienceId - Experience ID for [LINK] replacement
 * @returns Transition message or null
 */
export async function getTransitionMessage(
	funnelFlow: FunnelFlow, 
	userName?: string, 
	companyName?: string,
	experienceId?: string
): Promise<string | null> {
	try {
		if (!funnelFlow.startBlockId) {
			console.error("No startBlockId found in funnel flow");
			return null;
		}

		const startBlock = funnelFlow.blocks[funnelFlow.startBlockId];
		if (!startBlock) {
			console.error(`Start block ${funnelFlow.startBlockId} not found in funnel flow`);
			return null;
		}

		if (!startBlock.message || startBlock.message.trim() === "") {
			console.error("Start block has no message or empty message");
			return null;
		}

		let transitionMessage = startBlock.message;

		// Replace [USER] with first word of user name
		if (userName) {
			const firstName = userName.split(' ')[0]; // Get only the first word
			transitionMessage = transitionMessage.replace(/\[USER\]/g, firstName);
		}

		// Replace [WHOP] with actual company name
		if (companyName) {
			transitionMessage = transitionMessage.replace(/\[WHOP\]/g, companyName);
		}

		// Resolve [LINK] placeholder with app link
		if (transitionMessage.includes('[LINK]')) {
			if (experienceId) {
				const appLink = await generateAppLink(experienceId);
				transitionMessage = transitionMessage.replace(/\[LINK\]/g, appLink);
				console.log(`[Transition Message] Replaced [LINK] with: ${appLink}`);
			} else {
				console.log(`[Transition Message] No experienceId provided, keeping [LINK] placeholder`);
			}
		}

		// Add UserChat link if not already present and no [LINK] placeholder
		if (!transitionMessage.includes('[LINK]') && !transitionMessage.includes('UserChat') && !transitionMessage.includes('whop.com')) {
			if (experienceId) {
				const appLink = await generateAppLink(experienceId);
				transitionMessage += `\n\n${appLink}`;
			} else {
				transitionMessage += "\n\n[LINK]";
			}
		}

		return transitionMessage;
	} catch (error) {
		console.error("Error extracting welcome message:", error);
		return null;
	}
}

/**
 * Send transition DM to user
 * 
 * @param whopUserId - Whop user ID
 * @param message - Message to send
 * @returns Success boolean
 */
export async function sendTransitionDM(
	whopUserId: string,
	message: string,
	conversationId?: string,
): Promise<boolean> {
	try {
		console.log(`Sending DM to user ${whopUserId}: ${message}`);

		const result = await whopSdk.messages.sendDirectMessageToUser({
			toUserIdOrUsername: whopUserId,
			message: message,
		});

		// Record transition message in database if conversationId is provided
		if (conversationId) {
			await addMessage(conversationId, "bot", message);
			console.log(`Recorded transition message in conversation ${conversationId}`);
		}

		console.log(`DM sent successfully to user ${whopUserId}`);
		return true;
	} catch (error) {
		console.error(`Error sending DM to user ${whopUserId}:`, error);
		
		// Handle specific error cases
		if (error instanceof Error) {
			if (error.message.includes("rate limit")) {
				console.error("Rate limited when sending DM");
			} else if (error.message.includes("invalid user")) {
				console.error("Invalid user ID provided");
			}
		}
		
		return false;
	}
}

/**
 * Update conversation to WELCOME stage and save WELCOME message
 * 
 * @param conversationId - ID of the conversation to update
 * @param funnelFlow - Funnel flow to get WELCOME block
 */
export async function updateConversationToWelcomeStage(
	conversationId: string,
	funnelFlow: FunnelFlow,
): Promise<void> {
	try {
		// Find the WELCOME stage
		const welcomeStage = funnelFlow.stages.find(
			stage => stage.name === "WELCOME"
		);
		
		if (!welcomeStage || welcomeStage.blockIds.length === 0) {
			console.error(`No WELCOME stage found in funnel flow for conversation ${conversationId}`);
			return;
		}
		
		const firstWelcomeBlockId = welcomeStage.blockIds[0];
		const welcomeBlock = funnelFlow.blocks[firstWelcomeBlockId];
		
		if (!welcomeBlock) {
			console.error(`WELCOME block ${firstWelcomeBlockId} not found in funnel flow for conversation ${conversationId}`);
			return;
		}
		
		// Update conversation to WELCOME stage (using same pattern as navigate-funnel)
		const updatedConversation = await db
			.update(conversations)
			.set({
				currentBlockId: firstWelcomeBlockId,
				userPath: [firstWelcomeBlockId], // Start fresh with WELCOME block
				updatedAt: new Date(),
			})
			.where(eq(conversations.id, conversationId))
			.returning();
		
		console.log(`[USER-JOIN] Updated conversation ${conversationId} to WELCOME stage with block ${firstWelcomeBlockId}`, updatedConversation);
		
		// Save WELCOME message to database with placeholder resolution
		if (welcomeBlock.message) {
			// Resolve placeholders in WELCOME message
			let resolvedWelcomeMessage = welcomeBlock.message;
			
			// Get conversation to access experienceId and user info
			const conversation = await db.query.conversations.findFirst({
				where: eq(conversations.id, conversationId),
				columns: { experienceId: true, userId: true }
			});
			
			if (conversation) {
				// Resolve [USER] placeholder
				if (resolvedWelcomeMessage.includes('[USER]') && conversation.userId) {
					const user = await db.query.users.findFirst({
						where: eq(users.id, conversation.userId),
						columns: { name: true }
					});
					if (user?.name) {
						const firstName = user.name.split(' ')[0];
						resolvedWelcomeMessage = resolvedWelcomeMessage.replace(/\[USER\]/g, firstName);
						console.log(`[USER-JOIN] Resolved [USER] in WELCOME message: ${firstName}`);
					}
				}
				
				// Resolve [WHOP_OWNER] placeholder
				if (resolvedWelcomeMessage.includes('[WHOP_OWNER]')) {
					const adminUser = await db.query.users.findFirst({
						where: and(
							eq(users.experienceId, conversation.experienceId),
							eq(users.accessLevel, 'admin')
						),
						columns: { name: true }
					});
					if (adminUser?.name) {
						resolvedWelcomeMessage = resolvedWelcomeMessage.replace(/\[WHOP_OWNER\]/g, adminUser.name);
						console.log(`[USER-JOIN] Resolved [WHOP_OWNER] in WELCOME message: ${adminUser.name}`);
					}
				}
				
				// Resolve [LINK] placeholder
				if (resolvedWelcomeMessage.includes('[LINK]')) {
					const appLink = await generateAppLink(conversation.experienceId);
					resolvedWelcomeMessage = resolvedWelcomeMessage.replace(/\[LINK\]/g, appLink);
					console.log(`[USER-JOIN] Resolved [LINK] in WELCOME message: ${appLink}`);
				}
			}
			
			await db.insert(messages).values({
				conversationId: conversationId,
				type: "bot",
				content: resolvedWelcomeMessage,
				metadata: {
					blockId: firstWelcomeBlockId,
				},
			});
			console.log(`[USER-JOIN] Saved WELCOME message to database for conversation ${conversationId}:`, resolvedWelcomeMessage.substring(0, 100) + '...');
		}
		
	} catch (error) {
		console.error(`[USER-JOIN] Error updating conversation ${conversationId} to WELCOME stage:`, error);
		throw error;
	}
}

// Old tracking functions removed - now using background tracking service

